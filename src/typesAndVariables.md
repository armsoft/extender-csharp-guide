# Տիպեր և փոփոխականներ

## Բովանդակություն

- [Տիպեր և փոփոխականներ](#տիպեր-և-փոփոխականներ)
  - [Բովանդակություն](#բովանդակություն)
    - [C# լեզվի տիպերի համակարգը](#c-լեզվի-տիպերի-համակարգը)
    - [Փոփոխականի տիպի սահմանում այն հայտարարելու ժամանակ](#փոփոխականի-տիպի-սահմանում-այն-հայտարարելու-ժամանակ)
    - [Արժեքային և Հղում տեսակի տիպեր (Value types, Reference Types)](#արժեքային-և-հղում-տեսակի-տիպեր-value-types-reference-types)
    - [Ներքին արժեքային տեսակի տիպեր (Built-in Value types)](#ներքին-արժեքային-տեսակի-տիպեր-built-in-value-types)
      - [Ամբողջական թվեր](#ամբողջական-թվեր)
      - [Լողացող կետով թվեր](#լողացող-կետով-թվեր)
      - [Char](#char)
      - [Bool](#bool)
      - [Nullable value types](#nullable-value-types)
        - [nullable տիպի ստուգում](#nullable-տիպի-ստուգում)
        - [Փոխակերպում nullable տիպից հիմքային տիպի](#փոխակերպում-nullable-տիպից-հիմքային-տիպի)

### C# լեզվի տիպերի համակարգը

[C# type system]([C# type system](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/))

C# -ը հանդիսանում է խիստ տիպիզացված լեզու։ Ցանկացած փոփոխական կամ հաստատուն (constant) ունի որոշակի տիպ, որով որոշում է նրա հնարավոր արժեքները։

Կոմպիլյատորը օգտագործում է տիպերի վերաբերյալ տեղեկությունները ապահովվելու որ բոլոր գործողությունները, որոնք իրականացնում է ծրագիրը լինեն **տիպային անվտանգ** (type safe):

Օրինակ, եթե դուք հայտարարեք int տիպի (ամբողջական թիվ) փոփոխական, ապա կոմպիլյատորը թույլ կտա օգտագործել փոփոխականը գումարման և հանման գործողություններում քանի որ այն կարող է պարունակել միայն ամբողջ թիվ։ Սակայն, եթե ​​դուք փորձեք կատարել այդ նույն գործողությունները bool (true կամ false արժեքներ) տիպի փոփոխականի հետ՝ ապա կառաջանա սխալ։

```c#
int a = 5;
int b = a + 2; // գումարումը հաջողությամբ կկատարվի

bool test = true;

// Կառաջանա սխալ
int c = a + test;

```

### Փոփոխականի տիպի սահմանում այն հայտարարելու ժամանակ

[Specifying types in variable declarations](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/#specifying-types-in-variable-declarations)

Փոփոխական կամ հաստատուն հայտարարելիս անհրաժեշտ է նշել նրա տիպը կամ օգտագործել **var** հիմնաբառը, որպեսզի թույլ տալ կոմպիլյատորին եզրակացություն անել նրա տիպի վերաբերյալ: 

Փոփոխական հայտարարելուց հետո դուք չեք կարող այն վերահայտարարել նոր տիպով և չեք կարող նշանակել արժեք, որը անհամատեղելի է հայտարարված տիպի հետ: 

```c#
// Փոփոխականներրի հայտարարում:

// Փոփոխականը հայտարարելս նշվում է նրա տիպը և անունը
float temperature;
string name;
MyClass myClass;

// Փոփոխականի հայտարարություն արժեքի վերագրումով
// Արժեքի վերագրումը կատարվում է "=" օպերատորի միջոցով։ Օպերատորից աջ գտնվող արժեքը վերագրվում է ձախ կողմում նշված փոփոխականին

char firstLetter = 'C';
var limit = 3; // limit փոփոխականը կունենա int տիպ, քանի որ դա վերագրվող արժեքի տիպն է
int[] source = [0, 1, 2, 3, 4, 5]; // source փոփոխականը հանդիսանում է int արժեքներ պարունակող list

limit = "abc" // կառաջանա սխալ քանի որ վերագրվող արժեքը չի համապատասխանում փոփոխականի տիպին

```

### Արժեքային և Հղում տեսակի տիպեր (Value types, Reference Types)

[Value types (C# reference)](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/value-types)

**Արժեքային (Value Types)** և **Հղման (Reference Types)** տեսակները C# տեսակների երկու հիմնական կատեգորիաներն են: **Արժեքային** տեսակի փոփոխականը պարունակում է տիպի օրինակ (արժեքն անմիջապես): Սա տարբերվում է հղման տեսակի փոփոխականներից, որոնք պարունակում տվյալ տիպի օրինակի հղումը: 
Լռելյայնորեն, վերագրման ժամանակ, փոփոխականը ֆունկցիային որպես արգումենտ փոխանցելիս կամ ֆունկցիայի արժեքը վերադարձնելիս **Արժեքային** փոփոխականը պատճենվում է: **Հղման** տեսակի դեպքերում փոխանցվում է հղումը։ Սա նշանակում է, որ օրինակ մեկ փոփոխականը երկրորդին վերագրելուց հետո երկու փոփոխականը հղվելու են նույն օբյեկտի։


```c#
// Արժեքային  տիպերի դեպքում վերագրում կատարելիս արժեքը պատճենվում է

    int a = 5;
    int b = a; // b-ն և a-ն կունենան 5 արժեքը
    a = 25;  // a-ի արժեքը կդառնա 25 իսկ b -ի արժեքը կմնա 5։   

```

```c#
    //Հղման տեսակի դեպքերում փոխանցվում է հղումը

    List<int> l1 = [ 1, 2, 3 ]; // l1 փոփոխականը պարունակում է ամբողջ թվերի ցուցակի (List) հղումը, որը ունի՝   1, 2, 3 արժեքները։

    List<int> l2 = l1; // Հայտարարում ենք l2 փոփոխականը, որին անմիջապես վերագրում ենք l1-ը։ Արդյունքում l2-ին փոխանցվում է l1-ում պահվող հղումը։

    l1.Add(4); // l1 ցուցակում ավելացնում ենք 4 արժեքը։

    int lastElement = l2.Last(); // ստանում ենք l2 ցուցակի վերջին արժեքը, որը կլինի 4, քանի որ l1 և l2 պարունակում են հղում նույն ցուցակին։

```

### Ներքին արժեքային տեսակի տիպեր (Built-in Value types)

C#-ն ապահովում է [ներքին տիպերի ստանդարտ հավաքածու](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/value-types#built-in-value-types): Դրանք ներկայացնում են ամբողջ, տասնորդական և լողացող կետով թվեր, բուլյան արժեքներ, տեքստ և այլ տեսակի տվյալներ:

#### Ամբողջական թվեր

[Ամբողջական թվերի տիպեր](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/integral-numeric-types#characteristics-of-the-integral-types)

Ամբողջական թվերի տիպերը տարբերվում են՝ հնարավոր արժեքների միջակայքով, ինչպես նաև բացասական արժեք ունենալու հնարավորությամբ։ Ճիշտ ընտրված տիպը հնարավորություն է ընձեռնում նախ և առաջ տնտեսել հիշողությունը։

```c# 
// Տարիքի համար ընտրվել է byte տիպը (կարող է ունենալ արժեք 0-255 միջակայքում և զբաղեցնում է 8 բիթ), որը բավարար է մարդու տարիքի հետ աշխատելու համար
byte age = 30;
```


#### Լողացող կետով թվեր

[Lողացող կետով թվերի տիպեր](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types#characteristics-of-the-floating-point-types)

Ընդլայնումների ստեղծման ժամանակ այս տիպի թվերից ամենա հաճախակի գործածվողը դա **decimal** տիպն է։ Այն օգտագործվում է փողի համար։

```c#
//decimal տիպի Ֆիքսված արժեք վերագրելիս վերջում ավելացնում ենք m կամ M
decimal myMoney = 30.5m;
myMoney = 400_000.75M; // հնարավոր է օգտագործվել _ նիշը որպես բաժանարար, թիվը ավելի ընթեռնելի դարձնելու համար
```

#### Char

[char (C# reference)](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/char)

**Char** տիպը ներկայացնում է Unicode որևէ սիմվոլ։ Ֆիքսված արժեք (literal) վերագրելիս արժեքը պետք է ներառել ապաթարցերի մեջ։  

```c#
char c1 = 'j';   //  վերագրվում է j սիմվոլը

```

#### Bool

[bool (C# reference)](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/bool)

Bool տիպը ներկայացնում է բուլեան տիպի արժեք։ Այն կարող է ունենալ միայն երկու արժեք՝ **true**, **false**: Հնարավոր է օգտագործել **true**, **false** լիտերալները փոփոխականին արժեք վերագրելու համար։

```c#
bool checked = false; 

```

#### Nullable value types

[Nullable value types (C# reference)](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/nullable-value-types)

nullable տվյալների տիպը կարող է ունենալ տվյալ տիպին բնորոշ բոլոր արժեքները գումարած null արժեքը։ nullable տիպի փոփոխականները հայտարարելիս տիպի անվան վերջում ավելացվում է ? նշանը։ 

nullable արժեքը սովորաբար օգտագործում է երբ անհրաժեշտ է ներկայացնել որոշակի տիպի չսահմանված արժեքը: Օրինակ, Boolean կամ bool փոփոխականը կարող է լինել միայն **true** կամ **false**: Այնուամենայնիվ, որոշ դեպքերում փոփոխականի արժեքը կարող է սահմանված չլինել կամ բացակայել: Օրինակ, տվյալների բազայի դաշտը կարող է պարունակել **true** կամ **false**, կամ կարող է ընդհանրապես արժեք չպարունակել, այսինքն լինել NULL: 

```c#
bool? flag = null; // flag փոփոխականը կարող է ունենալ true, false կամ null արժեքները։
int? age = 30;
age = null;
flag = true;
```

##### nullable տիպի ստուգում

[Examination of an instance of a nullable value type](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/nullable-value-types#examination-of-an-instance-of-a-nullable-value-type)

nullable տիպերի հետ որոշակի գործողություն կատարելուց առաջ նախ և առաջ պետք է համոզվել որ նրա արժեքը null չէ։

```c#
int? qnt = null;

qnt = qnt + 10; // qnt փոփոխականի արժեքը, չնայած գումարման, կլինի null

```

Ստուգումը հնարավոր է կատարել **is** օպերատորի միջոցով։

```c#
int? a = 42;

/* a փոփոխականի ոչ null արժեքի դեպքում այն կվերագրվի valueOfA փոփխականին և կվերադարձվի true,
որի արդյունքում կկատարվի հաջորդող ձևավոր փաակագծերում սահմանված արտահայտությունը։ null արժեքի դեպքում
նշված արտահայտությունը չի կատարվի։
*/
if (a is int valueOfA) 
{
   a = valueOfA + 10; // a-ի արժեքը կլինի 52
}

```

nullable տիպերը ունեն **HasValue** և **Value** հատկությունները, որոնք հնարավոր է օգտագործել արժեքը ստուգելու համար։

```c#
int? a = 10;

if(a.HasValue) // Ստուգում է ոչ null արժեքի առկայությունը
{
    a = a + 10; // կամ a = a.Value + 10;
}

```

##### Փոխակերպում nullable տիպից հիմքային տիպի

[Conversion from a nullable value type to an underlying type](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/nullable-value-types#conversion-from-a-nullable-value-type-to-an-underlying-type)

Հաճախակի անհրաժեշտություն է առաջանում nullable տիպի համար սահմանելու հիմքային տիպին համապատասխանող որոշակի արժեք, որը պետք է կիրառել null արժեքի դեպքում։ Այդ նպատակով հնարավոր է օգտագործել ?? -  null-coalescing operator օպերատորը 

```c#
int? a = 28;
int b = a ?? -1;  // b փոփոխականը կստանա 28 արժեքը քանի որ a-ն null չէ։

int? c = null;
int d = c ?? -1; // d փոփոխականը կունենա -1 արժեքը, քանի որ c-ն null է։

```
