# Անանուն տիպեր (Anonymous types)

## Բովանդակություն

- [Անանուն տիպեր (Anonymous types)](#անանուն-տիպեր-anonymous-types)
  - [Բովանդակություն](#բովանդակություն)

Անանուն տիպերը հարմար միջոց են միայն ընթերցման համար նախատեսված հատկությունների հավաքածուն մեկ օբյեկտի մեջ ներառելու համար՝ առանց նախապես տիպ սահմանելու։ Տիպի անունը ստեղծվում է կոմպիլյատորի կողմից և հասանելի չէ սկզբնական կոդի մակարդակում։ Յուրաքանչյուր հատկության տեսակը որոշվում է կոմպիլյատորի կողմից։ Անանուն տիպերը ստեղվծում են օգտագործելով new օպերատորը օբյեկտի ինիցիալիզատորի հետ միասին։ Հետևյալ օրինակը ցույց է տալիս անանուն տիպ, որը նախնականացվում է երկու հատկություններով՝ «Գումար» և «Հաղորդագրություն»։

```c#
var v = new { Amount = 108, Message = "Hello" };

// Հետևյալ արտահայտությունում պահեք մկնիկի ցուցիչը v.Amount and v.Message - վրա 
// համոզվելու համար որ եզրակացված (inferred) տիպերն են՝ int և string.
Console.WriteLine(v.Amount + v.Message);

```

Անանուն տիպերը սովորաբար օգտագործվում են հարցման արտահայտության select պայմանում՝ սկզբնական հաջորդականության յուրաքանչյուր օբյեկտից հատկությունների ենթաբազմություն վերադարձնելու համար: Հարցումների մասին լրացուցիչ տեղեկությունների համար տե՛ս LINQ-ը C#-ում:

Ամենատարածված սցենարը անանուն տիպի ինիցիալիզացվում է՝ օգտագործելով մեկ այլ տիպի հատկություններ։ Հետևյալ օրինակում ենթադրենք, որ գոյություն ունի Product անունով դաս։ Product դասը ներառում է Color և Price հատկությունները, ինչպես նաև այլ հատկություններ, որոնք ձեզ չեն հետաքրքրում։

```c#
class Product
{
    public string? Color {get;set;}
    public  decimal Price {get;set;}
    public string? Name {get;set;}
    public string? Category {get;set;}
    public string? Size {get;set;}
}
```

Անանուն տիպի հայտարարագիրը սկսվում է `new` բանալի բառով։ Հայտարարությունը ինիցիալիզացնում է նոր տիպ, որն օգտագործում է Product-ի միայն երկու հատկություն։ Անանուն տիպերի օգտագործումը հանգեցնում է հարցման մեջ տվյալների ավելի փոքր քանակի վերադարձի։ Անդամների անունները չնշելու դեպքում անանուն տիպի մեջ, կոմպիլյատորը  անդամներին տալիս է հատկությունների անունները, որոնք օգտագործվել են դրանք ինիցիալիզացնելու համար։ Հատկությունների անունները տրվում են ինիցիալիզացիայի ժամանակ, ինչպես ցույց է տրված նախորդ օրինակում։ Հետևյալ օրինակում անանուն տիպի հատկությունների անուններն են Color և Price: Օրինակները Product տեսակների products կոլեկցիայի տարրեր են։

```c#
var productQuery =
    from prod in products
    select new { prod.Color, prod.Price };

foreach (var v in productQuery)
{
    Console.WriteLine("Color={0}, Price={1}", v.Color, v.Price);
}
```

Հնարավոր է դաշտ սահմանել նաև մեկ այլ տիպի օբյեկտով՝ class, struct կամ նույնիսկ մեկ այլ անանուն տիպի։ Դա արվում է այս օբյեկտը պահող փոփոխականի միջոցով, ինչպես հետևյալ օրինակում, որտեղ երկու անանուն տեսակներ ստեղծվում են արդեն իսկ ստեղծված օգտատիրոջ կողմից սահմանված տեսակների միջոցով։ Երկու դեպքում էլ անանուն shipment և shipmentWithBonus տիպի product դաշտերը կլինեն Product տիպի, որը պարունակում է յուրաքանչյուր դաշտի լռելյայն արժեքները։ Իսկ բոնուսային դաշտը կլինի կոմպիլյատորի կողմից ստեղծված անանուն տիպի։

```c#
var product = new Product();
var bonus = new { note = "You won!" };
var shipment = new { address = "Nowhere St.", product };
var shipmentWithBonus = new { address = "Somewhere St.", product, bonus };

```

Անանուն տիպի փոփոխականի ինիցիալիզացնելու համար, հայտարավում է անուղղակիորեն տիպավորված տեղական փոփոխական փոփոխական օգտագործելով var: Տիպի անունը չի կարող նշվել փոփոխականի հայտարարագրում, քանի որ միայն կոմպիլյատորն ունի հասանելիություն անանուն տիպի հիմքում ընկած անվան: Հնարավոր է ստեղծել անանուն տիպավորված տարրերի զանգված՝ համատեղելով անուղղակիորեն տիպավորված տեղական փոփոխականը և անուղղակիորեն տիպավորված զանգվածը, ինչպես ցույց է տրված հետևյալ օրինակում:

```c#
var anonArray = new[] { new { name = "apple", diam = 4 }, new { name = "grape", diam = 1 }};
```

Անանուն տիպերը դասի տիպեր են, որոնք ուղղակիորեն ժառանգվում են օբյեկտից և չեն կարող փոխակերպվել որևէ այլ տեսակի, բացի օբյեկտից: Կոմպիլյատորը յուրաքանչյուր անանուն տիպի համար անուն է տրամադրում, չնայած ձեր ծրագիրը չի կարող հասանելիություն ունենալ դրան, Common language runtime-ի տեսանկյունից, անանուն տիպը ոչնչով չի տարբերվում որևէ այլ հղման տիպից:

Եթե ասեմբլերում երկու կամ ավելի անանուն օբյեկտի ինիցիալիզատորներ նշում են նույն հերթականությամբ գտնվող և նույն անուններն ու տեսակները ունեցող հատկությունների հաջորդականություն, կոմպիլյատորը օբյեկտները դիտարկում է որպես նույն տիպի օրինակներ: Նրանք կիսում են կոմպիլյատորի կողմից ստեղծված նույն տիպի տեղեկատվությունը:

Անանուն տիպերը աջակցում են ոչ դեստրուկտիվ մուտացիան `with` արտահայտություններով տեսքով: Սա թույլ է տալիս ստեղծել անանուն տիպի նոր օրինակ, որտեղ մեկ կամ ավելի հատկություններ ունեն նոր արժեքներ.

```c#
var apple = new { Item = "apples", Price = 1.35 };
var onSale = apple with { Price = 0.79 };
Console.WriteLine(apple);
Console.WriteLine(onSale);
```

Հնարավոր չէ դաշտը, հատկությունը, իրադարձությունը կամ մեթոդի վերադարձվող տիպը հայտարարել որպես անանուն տիպ։ Նմանապես, դուք չեք կարող մեթոդի, հատկության, կոնստրուկտորի կամ ինդեքսատորի ֆորմալ պարամետրը հայտարարել որպես անանուն տիպ ունեցող։

Անանուն տիպը կամ անանուն տիպեր պարունակող հավաքածուն որպես մեթոդի արգումենտ փոխանցելու համար կարող եք պարամետրը հայտարարել `object` տիպի։ Այնուամենայնիվ, անանուն տիպերի համար օբյեկտի օգտագործումը խաթարում է ուժեղ տիպավորման նպատակը։ Եթե դուք պետք է պահպանեք հարցման արդյունքները կամ փոխանցեք դրանք մեթոդի սահմանից դուրս, խորհուրդ է տրվում օգտագործել սովորական անունով կառուցվածք (struct) կամ դաս (class)՝ անանուն տիպի փոխարեն։

Քանի որ անանուն տիպերում Equals և GetHashCode մեթոդները սահմանված են տվյալ տիպի հատկությունների Equals և GetHashCode մեթոդների հիման վրա, ապա նույն անանուն տիպի երկու օրինակներ համարվում են հավասար միայն այն դեպքում, երբ դրանց բոլոր հատկությունները հավասար են։

```c#
var person1 = new { Name = "Anna", Age = 30 };
var person2 = new { Name = "Anna", Age = 30 };

Console.WriteLine(person1.Equals(person2)); // True
Console.WriteLine(person1 == person2);      // False
```
